[{"title":"力扣热题 100 之哈希","tags":["哈希"],"categories":["LeetCode","Hot100"],"author":"Amireon","excerpt":"\n## 1. 两数之和\nhttps://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-li","link":"/posts/top-100-liked-hash","content":"\n## 1. 两数之和\nhttps://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked\n\n【题干】\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n\n你可以按任意顺序返回答案。\n\n【分析】\n\n暴力法，双重循环一个一个元素找，时间复杂度为 $O(N^2)$。\n\n[官方题解](https://leetcode.cn/problems/two-sum/solutions/434597/liang-shu-zhi-he-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked)：\n\n暴力法中时间复杂度高的原因是对于元素`x`，寻找`target-x`的时间复杂度高。因此，因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n\n使用哈希表，可以将寻找 `target - x` 的时间复杂度降低到从 `O(N)` 降低到 `O(1)`。\n\n对于每一个`x`，首先在哈希表中查询是否存在`target-x`，然后将`x`插入哈希表。如果存在，皆大欢喜；如果不存在，继续遍历。\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashtable;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto it = hashtable.find(target - nums[i]);\n            if (it != hashtable.end()) {\n                return {it->second, i};\n            }\n            hashtable[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n\n## 49. 字母异位词分组\n\nhttps://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked\n\n【题干】\n\n给你一个字符串数组，请你将`字母异位词`组合在一起。可以按任意顺序返回结果列表。\n\n【分析】\n\n字母异位词：两个字符串包含的字母相同。因此可以将排序后的字符串字母作为哈希表的键，字符串作为值的一部分（若干个值可以用可变数组存放）。\n\n```c++\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> ans;\n        unordered_map<string, vector<string>> mp;\n        for(int i = 0; i < strs.size();i++){\n            string key = strs[i];\n            sort(key.begin(), key.end());\n            mp[key].emplace_back(move(strs[i]));\n        }\n        for(auto& it: mp){\n            ans.emplace_back(move(it.second));\n        }\n        return move(ans);\n    }\n};\n```\n\n## 128. 最长连续序列\n\nhttps://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked\n\n【题干】\n\n给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n\n【分析】\n\n暴力法，直接快速排序，时间复杂度 `O(nlogn)`，不满足要求。\n\n[官方题解](https://leetcode.cn/problems/longest-consecutive-sequence/solutions/276931/zui-chang-lian-xu-xu-lie-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked)没看懂\n\n\n【代码】\n\n```c++\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> num_set;\n        for (const int& num : nums) {\n            num_set.insert(num);\n        }\n\n        int longestStreak = 0;\n\n        for (const int& num : num_set) {\n            if (!num_set.count(num - 1)) {\n                int currentNum = num;\n                int currentStreak = 1;\n\n                while (num_set.count(currentNum + 1)) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n\n                longestStreak = max(longestStreak, currentStreak);\n            }\n        }\n\n        return longestStreak;           \n    }\n};\n```"},{"title":"面试经典 150 题之数组/字符串篇","tags":["数组"],"categories":["LeetCode","Top150"],"author":"Amireon","excerpt":"\nLeetCode 链接：https://leetcode.cn/studyplan/top-interview-150/\n\n## 88.合并两个有序数组\n\nhttps://leetcode.cn/p","link":"/posts/top-interview-150-array","content":"\nLeetCode 链接：https://leetcode.cn/studyplan/top-interview-150/\n\n## 88.合并两个有序数组\n\nhttps://leetcode.cn/problems/merge-sorted-array/description/\n\n【题干】\n\n给你两个按 非递减顺序 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。\n\n请你 合并 `nums2` 到 `nums1` 中，使合并后的数组同样按 非递减顺序 排列。\n\n注意：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 m 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2 `的长度为 `n `。\n\n题目没有时间、空间上的任何要求\n\n### 方法一：直接合并后排序\n\n将 nums2 中的元素添加到 nums1 的尾部，然后对 nums1 整个数组进行排序。\n\n```c\nint cmp(int *a, int *b) {\n    return *a - *b;\n}\n\nvoid merge(int* nums1, int m, int* nums2, int n) {\n    for (int i = 0;i < n; i++) {\n        nums1[m + i] = nums2[i];\n    }\n    qsort(nums1, m + n, sizeof(int), cmp);\n}\n```\n\n复杂度分析\n\n- 时间复杂度：复制元素 O(m), 套用快速排序的序列长度 m+ n, 复杂度为 O((m + n)log(m + n))。\n- 空间复杂度：O(log(m + n))。排序序列长度为 m + n，套用快排的空间复杂度 O(log(m + n))。\n\n### 方法二: 双指针\n\n用两个指针 p1, p2 分别指向 nums1, nums2，比较当前指向元素 nums1[p1] 和 nums2[p2] 的大小。需要额外开辟一个存储新数组的空间。\n\n```c++\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int p1 = 0, p2 = 0, i = 0;\n        while (p1 < m && p2 < n) {\n            if (nums1[p1] <= nums2[p2]) {\n                nums[i] = nums1[p1];\n                p1++;\n            }\n            else {\n                nums[i] = nums2[p2];\n                p2++;\n            }\n            i++;\n        }\n        while (p1 < m) {\n            nums[i++] = nums1[p1++];\n        }\n        while (p2 < n) {\n            nums[i++] = nums2[p2++];\n        }\n        for(i = 0; i < m + n; i++) {\n            nums1[i] = nums[i];\n        }\n    }\n};\n```\n\n复杂度分析\n\n- 时间复杂度: O(2(m + n)) = O(m + n)。指针单向移动两次序列。\n- 空间复杂度: O(m + n)。需要一个额外的辅助空间存储 m + n 个元素。\n\n### 方法三：逆向双指针\n\n使用两个指针逆向遍历两个数组，从大到小将元素存储在 nums1 中。\n\n```c\nvoid merge(int* nums1, int m, int* nums2, int n) {\n    int p1 = m - 1, p2 = n - 1;\n    int cur = m + n - 1;\n    while (p1 >= 0 && p2 >= 0) {\n        if (nums1[p1] >= nums2[p2]) {\n            nums1[cur--] = nums1[p1--];\n        }\n        else {\n            nums1[cur--] = nums2[p2--];\n        }\n    }\n    while (p1 >= 0) {\n        nums1[cur--] = nums1[p1--];\n    }\n    while (p2 >= 0) {\n        nums1[cur--] = nums2[p2--];\n    }\n}\n```\n\n复杂度分析：\n\n- 时间复杂度: O(m + n)。遍历一次 nums1, nums2 的序列。\n- 空间复杂度: O(1)。额外空间不随序列长度变化。\n\n## 27.移除元素\n\nhttps://leetcode.cn/problems/remove-element/description/\n\n【题干】\n\n给你一个数组 nums 和 一个值 val，你需要原地移除所有数值等于 val 的元素。元素的顺序可能发生改变，然后返回 nums 中与 val 不同的元素的数量。\n\n假设 nums 中不等于 val 的元素数量为 k，要通过此题，您需要执行如下操作：\n\n- 更改 nums 数组，使得 nums 的前 k 个元素不包含等于 val 的元素。nums 的其余元素和 nums 的长度不重要。\n- 返回 k。\n\n【分析】\n\n如果允许使用额外空间，可以将 nums 中不等于 val 的元素存储到 nums2 中，然后再将 nums2 中的元素复制回 nums1。\n\n但是此题不允许使用额外空间。那可以试着记录下等于 val 的元素位置 l，然后将后面的不等于 val 的元素（位置记为 r）移动到位置 l。左右两个指针：右指针 r 指向当前要处理的元素，左指针 l 指向下一个要赋值的位置。\n\n- 如果 r 指向的元素 e 不等于 val，e 一定要被输出，那么将 e 移动到 l 指向的位置，l，r 同时右移。\n- 如果 r 指向的元素 e 等于 val，那么 e 不用管，r 右移，l 不动。\n\n### 双指针\n\n```c\nint removeElement(int* nums, int numsSize, int val) {\n    int l = 0, r = 0;\n    for (; r < numsSize; r++) {\n        if (nums[r] != val) {\n            nums[l] = nums[r];\n            l++;\n        }\n    }\n    return l;\n}\n```\n\n复杂度分析\n\n- 时间复杂度：O(n)，n 为序列长度，只需要遍历序列一次。\n- 空间复杂度：O(1)，只需要常数空间存储两个指针。\n\n## 26.移除有序数组中的重复项\n\nhttps://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/\n\n【题干】\n\n【分析】\n\n和上面那道“移除元素”非常相似。如果允许额外空间，可以用一个集合记录 nums 中的所有元素。但是只能用常数空间，还是采用双指针。右指针 r 指向当前要处理的元素，左指针 l 指向下一个要存储元素的位置。\n\n第一个元素天然保留，从第 2 个元素思考, l 和 r 的初始值都是 1。需要判断当前位 r 和 上一位 r - 1 的元素是否相等，\n\n- 如果相等，r 右移一位，l 不动。\n- 如果不相等，nums[l] = nums[r]，r 和 l 同时右移一位.\n\n```c\nint removeDuplicates(int* nums, int numsSize) {\n    if (numSize == 0) {\n        return 0;\n    }\n    int l = 1, r = 1;\n    while (r < n) {\n        if (nums[r] != nums[r - 1]) {\n            nums[l] = nums[r];\n            ++l;\n        }\n        ++r;\n    }\n    return l;\n}\n```\n\n复杂度分析\n\n- 时间复杂度：O(n), 其中 n 是数组的长度。\n- 空间复杂度：O(1)，只需要常数空间。\n\n## 删除有序数组中的重复项 II\n\nhttps://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/\n\n此题是[26.移除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)的翻版。\n\n【分析】\n\n元素可以重复两次，nums 前两个元素天然保留，从第 2 个元素思考，l 和 r 的初始值都是 2。需要判断 nums[r] 与 nums[l - 2] 是否相等。\n\n```c\nint removeDuplicate(int* nums, int numsSize) {\n    if (numsSize <= 2) {\n        return numSize;\n    }\n    int l = 2, r = 2;\n    while (r < numSize) {\n        if(nums[l - 2] != nums[r]) {\n            nums[l] = nums[r];\n            ++l;\n        }\n        ++r;\n    }\n    return l;\n}\n```\n\n## 169.多数元素\n\nhttps://leetcode.cn/problems/majority-element/\n\n【题干】\n\n给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 `⌊ n/2 ⌋` 的元素。\n\n- 方法一：排序后返回`nums[n/2]`的值\n- 方法二：用一个`map`统计每个元素出现的次数\n- 方法三：投票统计。\n\n### 方法二：统计元素出现次数\n\n用一个`map`统计`nums`中各个数字的出现次数，返回出现次数最多的元素的值.\n\n```c++\nclass Solution{\npublic:\n    int majorityElement(vector<int>& nums){\n        unordered_map<int, int> counts;\n        int ans = 0 , cnt = 0;\n        for(int num: nums){\n            ++counts[num];\n            if(counts[num] > cnt){\n                ans = num;\n                cnt = counts[num];\n            }\n        }\n        return ans;\n    }\n};\n```\n\n复杂度分析：\n- 时间复杂度：`O(n)`，遍历一次序列。\n- 空间复杂度：`O(n)`，平均而言。\n\n### 方法三：投票计数\n\n假设某个数`candidate`是众数，无论序列如何排列，`candidate` 的出现次数大于等于其他元素出现次数的总和。维护一个候选值`candidate`和它的出现次数`count`，遍历数组，对于每个元素`x`，\n\n- 如果 `x` 与 `candidate` 相等，那么计数器 `count` 的值增加 1；\n- 如果 `x` 与 `candidate` 不等，那么计数器 `count` 的值减少 1。如果`count`值小于 0，则更换`candidate`为`x`， `count`设为 1。\n\n遍历结束后，`candidate`即为整个数组的众数。\n\n```c\nint majorityElement(int* nums, int numsSize) {\n    int ans = nums[0];\n    int cnt = 1;\n    for(int i = 1; i < numsSize; i++){\n        if(nums[i] == ans){\n            ++cnt;\n        } else {\n            --cnt;\n            if(cnt < 0){\n                ans = nums[i];\n                cnt = 1;\n            }\n        }\n    }\n    return ans;\n}\n```\n\n复杂度分析\n- 时间复杂度：`O(n)`，只需遍历一次序列。\n- 空间复杂度：`O(1)`，常数空间存储候选。\n\n\n## 189.轮转数组\n\nhttps://leetcode.cn/problems/rotate-array/description/\n\n【题干】\n\n给定一个整数数组`nums`，将数组中的元素向右轮转`k`个位置，其中`k`是非负数。\n\n【分析】\n\n1. 来回拷贝。用一个额外数组在正确位置存储轮转后的元素，然后将新数组拷贝回去。\n2. 环状轮转。\n3. 翻转数组。需要翻转三次，`[0, n-1]`, `[0, k-1]`, `[k, n-1]`。\n\n\n### 方法二：环状轮转\n\n方法一中需要一个额外空间存储中间数值，那么是否可以省略掉这个空间呢？\n\n先考虑轮转步骤。不妨设从 `x0` 开始，中间值`temp==nums[x0]`，要移动到的位置为`x1`，\n1. 计算移动位置 `x1 = (x0 + k) mod n`，\n2. 交换`temp`和`nums[x0]`的值，`x0`设为`x1`，\n3. 重复上述1,2，直到结束。\n\n不妨设从 0 开始，那么一定会回到 0 的位置，但此时有的元素还没有完成更新（因为是跳跃式的），那么该怎么判断停止条件？\n\n> 说实话，这里的逻辑链条比较跳跃，跟不上。\n\n官解是考虑元素数量：从 0 开始不断遍历，最终回到起点 0 的过程中，遍历了多少个元素？由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为 a 圈；再设该过程总共遍历了 b 个元素。因此，我们有 `an=bk`，即 an 一定为 n,k 的公倍数。又因为我们在第一次回到起点时就结束，因此 a 要尽可能小，故 `an` 就是 n,k 的最小公倍数 `lcm(n,k)`，因此 b 就为 `lcm(n,k)/k`。\n\n这说明单次遍历会访问到 `lcm(n,k)/k` 个元素。为了访问到所有的元素，我们需要进行遍历的次数为\n$$\\dfrac{n}{\\mathrm{lcm}(n, k)/k} = \\dfrac{nk}{lcm(n,k)} = \\gcd(n, k)$$\n​\n```c\nint gcd(int a, int b){\n    return b ? gcd(b, a % b) : a;\n}\n\nvoid swap(int *a, int* b){\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid rotate(int*nums, int n, int k){\n    k = k % n;\n    int count = gcd(k, n);\n    for(int start = 0; start < count; start++){\n        int cur = start;\n        int prev = nums[strat];\n        do{\n            int next = (cur + k) % n;\n            sawp(&nums[next], &prev);\n            cur = next;\n        } while(start != cur);\n    }\n}\n```\n\n\n### 方法三：翻转数组\n\n观察给出的两个示例，可以总结出如下规律。\n1. 现将整个数组逆序。\n2. 逆序 `nums[0...(k-1)]`\n3. 逆序 `nums[k...(n-1)]`\n\n```c\nvoid swap(int* a, int* b){\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid reverse(int nums*, int start, int end){\n    while(start < end){\n        swap(&nums[start++], &nums[--end]);\n    }\n}\n\nvoid rotate(int nums*, int n, int k){\n    k = k % n;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, n - 1);\n}\n```\n\n\n## 121.买卖股票的最佳时机\n\nhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/\n\n【题干】\n\n给定一个数组`prices`，它的第`i`个元素`prices[i]`表示一支股票在第`i`天的价格。\n\n你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。\n\n设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。\n\n【分析】\n\n假设给定的数组为：`[7, 1, 5, 3, 6, 4]`，如果我们在图表上绘制给定数组中的数字，我们将会得到：\n\n![](https://pic.leetcode-cn.com/cc4ef55d97cfef6f9215285c7573027c4b265c31101dd54e8555a7021c95c927-file_1555699418271)\n\n如果想要得到最大收益，那肯定是在最低点买入，在最高点卖出。那么我们只需要使用一个变量`minprice`记录历史最低价格，假设在这一天买入股票。现在第`i`天卖出，那么所得收益为`prices[i] - minprice`。\n\n因此，只需要遍历一次数组，记录下到第`i`天的历史最低价格，每一天都考虑买入卖出，比较最大收益。\n\n```c\nint maxProfit(int* prices, int pricesSize) {\n    int maxprofit = 0;\n    int minprice = 1e4 + 10;\n\n    for (int i = 0; i < pricesSize; i++) {\n        maxprofit = prices[i] - minprice > maxprofit ? prices[i] - minprice : maxprofit;\n        minprice = prices[i] < minprice ? prices[i] : minprice;\n    }\n\n    return maxprofit;\n}\n```\n\n## 122.买卖股票的最佳时机II\n\nhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/\n\n【题干】\n\n给你一个整数数组`prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。\n\n返回你能获得的最大利润 。\n\n【分析】\n\n与 121.买卖股票的最佳时机 不同的是，这次可以多次买入卖出。那么如果明天价格比今天高，就今天买明天卖。如果后天比明天还高呢？有两种方法，一种还是今天买明天卖，等到下一天，后天就是下一个明天。第二种方法是，等到价格最高点卖（递增子序列的最高点）。当然这两种方法没有本质区别。\n\n这里使用第二种，求一个数组中各个递增子序列的`最大值-最小值`的和。\n\n```c\nint maxProfit(int* prices, int pricesSize) {\n    // 查找递增子序列中的最大值\n    int maxprofit = 0, maxprice = 0; // 最大收益, 递增子序列中的最大元素值\n    int i = 0, j = 0;     // 遍历起始点, 查找递增序列\n    while(i < pricesSize){\n        maxprice = prices[i];\n        j = i + 1;\n        while(j < pricesSize){ // 找不到递增序列就停下\n            if(prices[j] >= maxprice){\n                maxprice = prices[j];\n                j++;\n            }else{\n                break;\n            }\n        }\n        maxprofit = maxprofit + maxprice - prices[i];\n        i = j;  // 跳转到下一个递增子序列的起始位置\n    }\n    return maxprofit;\n}\n```\n\n## 55.跳跃游戏\n\nhttps://leetcode.cn/problems/jump-game/description/\n\n【题干】\n\n给你一个非负整数数组 `nums` ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。\n\n【分析】\n\n分析下给定的示例，可以发现能否到达数组尾部，取决于能否跳过数组中的元素 0。如果刚好卡在了 0 的位置，那么到此为止。数组最后一个元素值是几不用理会。\n\n这里选择逆序检查是否能跳过 0.\n\n```c\nbool canJump(int* nums, int numsSize) {\n    // 从后到前检查 0\n    int step = 1; // 走到目标所需的步数\n    for(int i = numsSize - 2; i >= 0; i--){\n        if(nums[i] >= step){\n            // 可以走到\"下一个\"位置(可能是后面好几位的位置)\n            step = 0;\n        }\n        ++step;\n    }\n    return step == 1; // 正确情况下应该是 1, 大于 1 说明无法跳过 0\n}\n```\n\n## 45.跳跃游戏2\n\nhttps://leetcode.cn/problems/jump-game-ii/description/\n\n【题干】\n\n给定一个长度为 `n` 的 0 索引整数数组 `nums`。初始位置为 `nums[0]`。\n\n每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在 `nums[i] `处，你可以跳转到任意 `nums[i + j]` 处:\n\n返回到达 `nums[n - 1]`的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。\n\n- `0 <= j <= nums[i] `\n- `i + j < n`\n\n【分析】\n\n这次是要求出最小跳跃次数。可以用动态规划做。求从`0`到达`i`的最小步数，可以从 `[0..i-1]` 中求到 `i` 的最小步数 + 1 ，然后与原有最小步数（可以初始化为一个极大值）比较。\n\n递推公式为：`dp[i] = min(dp[j] + 1, dp[i]), 0 <= j <= i - 1` \n\n时间复杂度为`O(n*2)`，很高的一个值。\n\n```c\nint min(int a, int b){\n    return a > b ? b : a;\n}\n\nint jump(int* nums, int numsSize) {\n    if(nums[0] == 0 || numsSize <= 1){\n        return 0;\n    }\n    // 到达最后一个索引的最小跳跃次数\n    int dp[numsSize]; // 从 0 到 i 的最小步数\n    // 前两个值固定\n    dp[0] = 0;\n    dp[1] = 1;\n\n    for(int i = 2; i < numsSize; i++){\n        dp[i] = 1e4 + 10;\n        for(int j = i - 1; j >= 0; j--){\n            if(j + nums[j] >= i){// 可以到达\n                dp[i] = min(dp[j] + 1, dp[i]);\n            }\n        }\n    }\n\n    return dp[numsSize - 1];\n}\n```\n\n## 274.H 指数\n\nhttps://leetcode.cn/problems/h-index/description/\n\n【题干】\n\n给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 `h` 指数。\n\n根据维基百科上 `h` 指数的定义：`h` 代表“高引用次数” ，一名科研人员的 `h` 指数 是指他（她）至少发表了 `h` 篇论文，并且 至少 有 `h`篇论文被引用次数大于等于 `h` 。如果 `h` 有多种可能的值，`h` 指数 是其中最大的那个。\n\n【分析】\n\n问题本质是：有若干个元素 `e` ，其满足条件： 数组中有不少于 `e` 个元素的值不小于 `e`。求 `e`的最大值\n1. 统计数组各个元素值的数量`h[0...maxcitation]`\n2. 倒序遍历数组，遇到的第一个满足`sum >= i`即为所求, `sum`是`h[i...maxciataion]`的和\n\n```c\nint hIndex(int* citations, int citationsSize) {\n    // 某个元素 e 满足条件： 数组中有不少于 e 个元素的值 >= e, 求 e 的最大值\n    int h[1001] = {0}; // 引用次数为 i 的论文数量为 h[i]\n    int max = 0, sum = 0, tmp = 0;\n    for(int i = 0; i < citationsSize; i++){\n        tmp = citations[i];\n        h[tmp]++;\n        max = tmp > max ? tmp : max;\n    }\n    for(int i = max; i > 0; i--){\n        sum += h[i];\n        if(sum >= i){\n            return i;\n        }\n    }\n    return 0;\n}\n```\n\n## 380. O(1) 时间插入、删除和获取随机元素\nhttps://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150\n\n【题干】\n\n实现 `RandomizedSet` 类：\n\n- `RandomizedSet()` 初始化 `RandomizedSet` 对象\n- `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。\n- `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。\n- `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有相同的概率被返回。\n\n你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 `O(1)` 。\n\n【分析】\n\n变长数组可以在 O(1)的时间内随机获取元素，但无法保证元素是否存在。如果加上判断操作，时间复杂度为 O(n)。同样地，插入和删除操作都无法在 O(1)的时间内完成。\n\n哈希表可以在 O(1) 的时间内完成插入和删除操作，但在不提供下标的情况下，无法在 O(1)的时间内随机获取某个元素。\n\n因此，结合变长数组和哈希表：\n- 变长数组：存储元素\n- 哈希表：键为元素，值为元素在数组中的下标\n\n插入操作：\n1. 判断 `val` 是否在哈希表中，在就返回 `true`，不在进入 2.\n2. 将 `val` 插入数组末尾，记录下标 idx\n3. 将 `val - idx` 插入哈希表\n\n删除操作：\n1. 判断 `val` 是否在哈希表中，不在返回 `false`，在进入 2.\n2. 从哈希表中得到 `val` 的下标 `idx`\n3. 将数组的最后一个元素`last` 复制到 `idx`, 在哈希表中将 `last`的下标改为`idx`\n4. 在数组中删除最后一个元素，在哈希表中删除 `val`\n\n【代码】\n\n```c++\nclass RandomizedSet {\nprivate:\n    vector<int> nums;\n    unordered_map<int, int> indices;\n\npublic:\n    RandomizedSet() {\n        srand((unsigned)time(NULL));\n    }\n    \n    bool insert(int val) {\n        if (indices.count(val)) {\n            return false;\n        }\n        int index = nums.size();\n        nums.emplace_back(val);\n        indices[val] = index;\n        return true;\n    }\n    \n    bool remove(int val) {\n        if (!indices.count(val)) {\n            return false;\n        }\n        int index = indices[val];\n        int last = nums.back();\n        nums[index] = last;\n        indices[last] = index;\n        nums.pop_back();\n        indices.erase(val);\n        return true;\n    }\n    \n    int getRandom() {\n        int randomIndex = rand() % nums.size();\n        return nums[randomIndex];\n    }\n};\n```\n\n## 238. 除自身以外数组的乘积\n\nhttps://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150\n\n【题干】\n\n给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。\n\n题目数据保证数组 `nums` 之中任意元素的全部前缀元素和后缀的乘积都在 32 位整数范围内。\n\n请不要使用除法，且在 `O(n)` 时间复杂度内完成此题。\n\n进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为 额外空间。）\n\n【分析】\n\n官方题解：https://leetcode.cn/problems/product-of-array-except-self/solutions/272369/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-by-leetcode-/?envType=study-plan-v2&envId=top-interview-150\n\n暴力法，将所有元素乘在一起，然后对数组的每个元素`x`，将总乘积除以`x`获得答案，但不允许使用除法。\n\n题干中提到了前缀积和后缀积。我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。\n> 真没想到这个做法\n\n**算法**\n- 初始化两个空数组 `L` 和 `R`。对于给定索引 `i`，`L[i]` 代表的是 `i` 左侧所有数字的乘积，`R[i]` 代表的是 `i` 右侧所有数字的乘积。\n- 我们需要用两个循环来填充 `L` 和 `R` 数组的值。对于数组 `L`，`L[0]` 应该是 1，因为第一个元素的左边没有元素。对于其他元素：`L[i] = L[i-1] * nums[i-1]`。\n- 同理，对于数组 `R`，`R[length-1]` 应为 1。`length` 指的是输入数组的大小。其他元素：`R[i] = R[i+1] * nums[i+1]`。\n- 当 `R` 和 `L` 数组填充完成，我们只需要在输入数组上迭代，且索引 `i` 处的值为：`L[i] * R[i]`。\n\n官解还给了两个优化版本\n- 优化一：将`answer` 数组当做 `L` 用，那么索引 `i` 处的值为：`answer[i] = answer[i] * R[i]`\n- 优化二：将 `R[]` 省略掉，用一个累乘值 `r == 1` 作为后缀积，那么索引 `i` 处的值为：`answer[i] = answer[i] * r, r = r * nums[i]`\n\n【代码】\n\n```c++\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int length = nums.size(), R = 1;\n        vector<int> answer(length);\n\n        // answer[i] 为索引 i 左侧所有元素的乘积\n        answer[0] = 1;\n        for (int i = 1; i < length; i++) {\n            answer[i] = nums[i - 1] * answer[i - 1];\n        }\n\n        // R 为索引 i 右侧所有元素的乘积\n        for (int i = length - 1; i >= 0; i--) {\n            answer[i] = answer[i] * R;\n            R = R * nums[i];\n        }\n\n        return answer;\n    }\n};\n```\n\n## 134. 加油站\n\nhttps://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150\n\n【题干】\n\n在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。\n\n你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。\n\n给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 保证 它是 唯一 的。\n\n【分析】\n\n假设起始点为 `start`，那么从 `0` 到 `start` 需要耗费的总油量 `allcost == cost[0] + ... + cost[start - 1]`，油箱的油量`allgas == gas[0+..+start-1]`，`allgas - allcost`的值为 `total`（有可能是负的，负的表示欠了）代表油箱剩余量，那么只需要到最后一个站之后的 `total` 不是负数，就表示能绕一圈。\n\n能否绕一圈的问题解决了，现在考虑从哪个点出发。我们知道，`i` 是否是出发点，取决于 `gas[i]`是否大于 等于`cost[i]`，用一个值记录当前油箱剩余量 `cap`，`cap >= 0`，能到达; `cap < 0`,将起始点换成下一个点 i+1，同时记录下 `gap[i]` 与 `cost[i]` 的差值。\n\n【代码】\n\n```c++\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int total = 0, cap = 0, tmp; // 剩余总油量, 当前油量, 中间值\n        int start = 0;  // 起始位置\n        for(int i = 0; i < gas.size(); i++){\n            tmp = gas[i] - cost[i];\n            total += tmp;\n            cap += tmp;\n            if(cap < 0){\n                // 当前油量不足以到达i+1, 换起始点\n                start = i + 1;\n                cap = 0;\n            }\n        }\n        return total >= 0 ? start : -1;        \n    }\n};\n```\n\n## 135. 分发糖果\nhttps://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150\n\n【题干】\n\n`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。\n\n你需要按照以下要求，给这些孩子分发糖果：\n\n- 每个孩子至少分配到 1 个糖果。\n- 相邻两个孩子中，评分更高的那个会获得更多的糖果。\n\n请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。\n\n【分析】\n\n至少一个，相邻的大者多一个，总数量最少 -> 相邻的谁大谁多一个\n\n可能左边大，可能右边大，那不妨从左侧、右侧分别遍历一次，然后取两者的较大值。\n\n> 为什么不是较小值？因为取了较小值后，另一个无法满足比领居多 1 个糖果。\n\n【代码】\n\n```c++\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        vector<int> left(n);\n        left[0] = 1;\n        for(int i = 1; i < n; i++){\n            if(ratings[i] > ratings[i - 1]){\n                left[i] = 1 + left[i - 1]; // 大的比小的多 1 个\n            } else {\n                left[i] = 1; // 变成了小的\n            }\n        }\n\n        int right = 0, total = 0;\n        for(int i = n - 1; i >= 0; i--){\n            if(i < n - 1 && ratings[i] > ratings[i + 1]){\n                right++; \n            } else {\n                right = 1; \n            }\n            total += max(left[i], right);\n        }\n        return total;\n    }\n};\n```\n\n\n## 58.最后一个单词的长度\nhttps://leetcode.cn/problems/length-of-last-word/?envType=study-plan-v2&envId=top-interview-150\n\n【题干】\n\n给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n\n【分析】\n\n倒序遍历字符串。不是空格长度+1，停止条件为遇到空格且长度大于 0（表示最后一个单词遍历完成）\n\n【代码】\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int count = 0;\n        for(int i = s.size() - 1; i >= 0; i--){\n            if(s[i] != ' '){\n                count++;\n            } else if(count > 0){\n                break;\n            }\n        }\n        return count;\n    }\n};\n```\n\n## 14.最长公共前缀\nhttps://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=top-interview-150\n\n【题干】\n\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串 `\"\"`。\n\n【分析】\n\n暴力解法，双循环。按位检查字符是否都在每一个字符串内。\n\n【代码】\n\n```c++\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if(strs.size() == 0)\n            return \"\";\n        string prefix = \"\";\n        char c;\n        string s = strs[0];\n        for(int i = 0; i < s.size(); i++){\n            c = s[i];\n            if(checkChar(strs, i, c)){\n                prefix += c;\n            } else {\n                break;\n            }\n        }\n\n        return prefix;\n    }\n\n    bool checkChar(vector<string>& strs, int a, int c){\n        for(string s: strs){\n            if(c != s[a]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```\n\n## 28.找出字符串中第一个匹配项的下标\n\nhttps://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/?envType=study-plan-v2&envId=top-interview-150\n\n【题干】\n\n给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回  -1 。\n\n【分析】\n\n暴力法：可以让字符串 needle 与字符串 haystack 的所有长度为 m 的子串均匹配一次。\n\n学过 408 的都知道，字符串匹配有一个经典算法：Knuth-Morris-Pratt 算法，简称 KMP 算法。\n\n官解：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/732236/shi-xian-strstr-by-leetcode-solution-ds6y/?envType=study-plan-v2&envId=top-interview-150\n\n【代码】\n\n来自官解的 KMP 算法。\n\n```c++\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int n = haystack.size(), m = needle.size();\n        if (m == 0) {\n            return 0;\n        }\n        vector<int> pi(m);\n        for (int i = 1, j = 0; i < m; i++) {\n            while (j > 0 && needle[i] != needle[j]) {\n                j = pi[j - 1];\n            }\n            if (needle[i] == needle[j]) {\n                j++;\n            }\n            pi[i] = j;\n        }\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j > 0 && haystack[i] != needle[j]) {\n                j = pi[j - 1];\n            }\n            if (haystack[i] == needle[j]) {\n                j++;\n            }\n            if (j == m) {\n                return i - m + 1;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n\n"},{"title":"面试经典 150 题之双指针篇","tags":["双指针"],"categories":["LeetCode","Top150https://leetcode.cn/problems/move-zeroes/"],"author":"Amireon","excerpt":"\n## 283. 移动零\n\n【题干】\n\n给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n\n","link":"/posts/top-interview-150-twopointers","content":"\n## 283. 移动零\n\n【题干】\n\n给定一个数组 `nums`，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n\n【分析】\n\n双指针，一个快指针和一个慢指针。快指针用与扫描数组元素，慢指针用于存储元素。\n\n每当快指针指向非 0 元素时，则交换两个指针的元素，同时慢指针右移一位。\n\n【代码】\n```c\nvoid swap(int *a, int *b){\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid moveZeros(int *nums, int numsSize){\n  int fast = 0, slow = 0;\n  while(fast < numsSize){\n      if(nums[fast]){\n          swap(nums + slow, nums + fast);\n          slow++;\n      }\n      fast++;\n  }\n}\n```"}]
